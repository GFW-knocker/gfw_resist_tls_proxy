# gfw_resist_tls_proxy
# internet for everyone or no one
Ø³Ù„Ø§Ù… Ú¯Ø±Ù… Ø¨Ù‡ Ù‡Ù…Ù‡ Ø¯ÙˆØ³ØªØ§Ù†ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ø­Ù‚ Ø§ÙˆÙ„ÛŒÙ‡ Ùˆ Ø§Ø¨ØªØ¯Ø§ÛŒÛŒ Ø´Ù‡Ø±ÙˆÙ†Ø¯ÛŒØŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø§ÛŒÙ†ØªØ±Ù†ØªØŒ ØªÙ„Ø§Ø´ Ù…ÛŒâ€ŒÚ©Ù†Ù†Ø¯.
<br>
Ø³Ù„Ø§Ù… Ø¨Ù‡ Ù‡ÛŒØ¯ÛŒÙØ§ÛŒØŒ Ø¨Ø§Ø´Ø³ÛŒØ²ØŒ Ø³Ú¯Ø§Ø±ÙˆØŒ Ø¢ÛŒ Ø¢Ø± Ø³ÛŒ Ø§ÙØŒ Ù¾Ø±ÙˆÚ˜Ù‡ Ø§Ù…ÛŒØ¯ØŒ Ø«Ù†Ø§ÛŒÛŒØŒ Ù‡Ú¯Ø²Ø§ØŒ ÙˆØ­ÛŒØ¯ØŒ ØµÙØ§ØŒ Ø§Ø±Ø¯Ø´ÛŒØ±ØŒ Ø§ÛŒÙ…Ø§Ù†ØŒ Ø§Ù…ÛŒÙ†ØŒ Ø­Ø³ÛŒÙ†ØŒ ÛŒÙˆØªÛŒÙˆØ¨Ø±Ù‡Ø§ Ùˆ Ù‡Ù…Ù‡â€ŒÛŒ Ø¹Ø²ÛŒØ²Ø§Ù† Ø¯ÙˆØ³Øª Ø¯Ø§Ø´ØªÙ†ÛŒ!
<br><br>
Ø±ÙˆØ´ Ø§ÛŒÙ† Ù¾ÛŒØ¬ØŒ ÛŒÚ© Ø²Ø®Ù… Ø¹Ù…ÛŒÙ‚ Ø¨Ø± Ù¾ÛŒÚ©Ø±  GFW  Ù…ÛŒâ€ŒÚ¯Ø°Ø§Ø±Ø¯ Ú©Ù‡ ØªØ§ Ø³Ø§Ù„â€ŒÙ‡Ø§ Ø³ÙˆØ²Ø´ Ø¢Ù† Ø¯Ø± Ù…Ø§ØªØ­Øª ÙÛŒÙ„ØªØ±Ú†ÛŒØ§Ù† Ø¯Ù†ÛŒØ§ Ø¨Ø§Ù‚ÛŒ Ø®ÙˆØ§Ù‡Ø¯ Ù…Ø§Ù†Ø¯. ğŸ˜	
<br>
<br>
Ø®Ù„Ø§ØµÙ‡â€ŒÛŒ Ú©Ø§Ø± Ø¨Ù‡ ÙØ§Ø±Ø³ÛŒ:<br>
Ø±ÙˆØªØ±Ù‡Ø§ÛŒ gfw ØªÙ„Ø§Ø´ Ù…ÛŒâ€ŒÚ©Ù†Ù†ØŒ Ø§Ù…Ø§ Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù† Ù‡Ù…Ù‡â€ŒÛŒ packet Ù‡Ø§ÛŒ fragment Ø±Ø§ Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ delay Ø¨ÛŒÙ† Ù¾Ú©Øª Ù‡Ø§ Ø¨Ø§Ø´Ù‡ Ø³Ø±Ù‡Ù… Ú©Ù†Ù†. <br>
Ú†Ø±Ø§ØŸ Ú†ÙˆÙ† Ú©Ù„ ØªØ±Ø§ÙÛŒÚ© Ú©Ø´ÙˆØ± Ø§Ø²Ø´ÙˆÙ† Ø¹Ø¨ÙˆØ± Ù…ÛŒâ€ŒÚ©Ù†Ù‡ Ùˆ Ø¨Ø±Ø§Ø´ÙˆÙ† Ø³Ø®ØªÙ‡Ø› Ù‡Ù…Ú†Ù†ÛŒÙ†ØŒ cache  Ù…Ø­Ø¯ÙˆØ¯ Ø¯Ø§Ø±Ù† Ùˆ Ø¨Ø§ÛŒØ¯ Ø³Ø±ÛŒØ¹ Ø¨Ø§Ø´Ù†.<br>
Ø§Ø² Ø·Ø±ÙÛŒØŒ gfw Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ Ù¾Ú©Øªâ€ŒÙ‡Ø§ÛŒ ÙØ±Ú¯Ù…Ù†Øª Ø±Ùˆ reject Ú©Ù†Ù‡ Ú†ÙˆÙ† Ø§ÙˆÙ„Ø§Ù‹ fragmet Ø¬Ø²Ùˆ Ø§ØµÙˆÙ„ Ø´Ø¨Ú©Ù‡ Ù‡Ø³ØªØ›<br>
Ø«Ø§Ù†ÛŒØ§Ù‹ Ø¯Ø± Ø®ÛŒÙ„ÛŒ Ø§Ø² Ù†Øª Ù‡Ø§ÛŒ Ø¶Ø¹ÛŒÙØŒ packet Ù‡Ø§ ØªÚ©Ù‡ Ù…ÛŒâ€ŒØ´Ù†.<br>
Ø¯Ø± ØµÙˆØ±Øª reject Ú©Ø±Ø¯Ù†ØŒ Ù†Øª Ø¨Ø³ÛŒØ§Ø±ÛŒ Ø§Ø² Ú¯ÙˆØ´ÛŒâ€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ Ùˆ Ø®Ø·ÙˆØ· Ø¶Ø¹ÛŒÙ Ù…Ø®ØªÙ„ Ù…ÛŒâ€ŒØ´Ù‡.<br>
Ù‡Ù…Ú†Ù†ÛŒÙ†ØŒ Ø¯Ø± Ù…Ø³ÛŒØ± Ø±ÙˆØªØ±Ù‡Ø§ÛŒ Ù¾Ø±Ø³Ø±Ø¹Øª fragmentation Ø§ØªÙØ§Ù‚ Ù…ÛŒâ€ŒØ§ÙØªÙ‡.<br>
Ùˆ gfw Ø§ÛŒÙ† Ø±Ùˆ Ù…ÛŒâ€ŒØ¯ÙˆÙ†Ù‡Ø› Ø¨Ù†Ø§Ø¨Ø±Ø§ÛŒÙ† Ø³Ø¹ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ù‡ Ø§Ø³Ù…Ø¨Ù„ Ú©Ù†Ù‡ Ùˆ Ø§Ú¯Ù‡ Ù†ØªÙˆÙ†Ù‡ØŒ Ø¹Ø¨ÙˆØ± Ù…ÛŒâ€ŒØ¯Ù‡.<br> 
Ø³Ø±ÙˆØ±Ù‡Ø§ Ø§Ù…Ø§ØŒ Ù…ÙˆØ¸Ù Ø¨Ù‡ Ø³Ø±Ù‡Ù… Ú©Ø±Ø¯Ù† fragment Ù‡Ø§ Ù‡Ø³ØªÙ†Ø› Ú†ÙˆÙ† Ø¯Ø± Ù¾Ø±ÙˆØªÚ©Ù„ Ø§ÛŒÙ†ØªØ±Ù†Øª (ip) Ù‚ÛŒØ¯ Ø´Ø¯Ù‡ Ùˆ Ø³Ø±Ø´ÙˆÙ† Ø¨Ù‡ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÛŒ gfw Ø´Ù„ÙˆØº Ù†ÛŒØ³Øª.<br>
Ø³Ø±ÙˆØ±Ù‡Ø§ÛŒ Ú©Ù„ÙˆØ¯ÙÙ„Ø± Ø¨Ù‡ Ø®ÙˆØ¨ÛŒ Ø§ÛŒÙ† Ú©Ø§Ø± Ø±Ùˆ Ù…ÛŒâ€ŒÚ©Ù†Ù†.<br>
Ø¨Ø§ÙˆØ± Ú©Ù†ÛŒØ¯ ÛŒØ§ Ù†Ù‡ØŒ Ú©Ø§Ø± gfw Ø³Ø§Ø®ØªÙ‡â€ŒØ³Øª!<br>
Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø¹Ù…Ø¯Ù‡â€ŒÛŒ ØªØ±Ø§ÙÛŒÚ© TLS Ù‡Ø³Øª Ùˆ ØªÙ†Ù‡Ø§ Ø¨Ø§ ØªØ­Ù„ÛŒÙ„ SNI Ù…ÛŒâ€ŒØªÙˆÙ†Ù‡ ØªØ±Ø§ÙÛŒÚ© TLS Ø±Ùˆ ØªÙÚ©ÛŒÚ© Ú©Ù†Ù‡Ø›<br>
Ùˆ Ù…Ø§ Ú©Ø§Ø± Ø±Ùˆ Ø¨Ø±Ø§Ø´ Ù‡Ø²ÛŒÙ†Ù‡â€ŒØ¨Ø± Ùˆ Ù¾Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ….<br>
ÛŒØ§ Ø¨Ø§ÛŒØ¯ Ú©Ù„ cloudflare Ø±Ùˆ Ø¨Ø§ Ù‡Ù…Ù‡â€ŒÛŒ Ø³Ø§ÛŒØªâ€ŒÙ‡Ø§Ø´ Ø¨Ø¨Ù†Ø¯Ù‡ Ùˆ Ø¹Ù…Ù„Ø§Ù‹ Ù†Øª Ø¬Ù‡Ø§Ù†ÛŒ Ø±Ùˆ Ù‚Ø·Ø¹ Ú©Ù†Ù‡ØŒ<br>
ÛŒØ§ Ø¨Ø§ÛŒØ¯ ÙØ±Ú¯Ù…Ù†Øª Ø±Ùˆ drop Ú©Ù†Ù‡Ø› Ú©Ù‡ Ø¯Ø± Ù‡Ø± ØµÙˆØ±Øª Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ¯Ø´ÙˆÙ† Ù‡Ù… Ø¯Ú†Ø§Ø± Ø§Ø®ØªÙ„Ø§Ù„ Ù…ÛŒâ€ŒØ´Ù‡.<br>
*Ø§ÛŒÙ† Ø³ÛŒØ³ØªÙ… ØªØ³Øª Ø´Ø¯Ù‡ Ùˆ Ú©Ø§Ø± Ù…ÛŒÚ©Ù†Ù‡*<br>
Ø´Ù…Ø§ Ø¨Ø§ domain ÙÛŒÙ„ØªØ± Ø´Ø¯Ù‡ Ùˆ Ø¨Ø§ ip Ú©Ø«ÛŒÙ cloudflare Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒØ¯ Ø§Ø² gfw Ø¹Ø¨ÙˆØ± Ú©Ù†ÛŒØ¯.<br>
Ø¨Ø§ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§Ù†Ø¯Ú©ØŒ Ø³Ø±Ø¹Øª handshake Ø§ÙˆÙ„ Ù‡Ù… Ø¨Ø§Ù„Ø§ Ø®ÙˆØ§Ù‡Ø¯ Ø±ÙØª.<br>
Ø§ÛŒÙ†ØªØ±Ù†Øª Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ ÛŒØ§ Ø¨Ø±Ø§ÛŒ Ù‡ÛŒÚ†Ú©Ø³!<br>


# goodbye SNI filtering & goodbye GFW mf'er
<img src="/asset/meme1.jpg?raw=true" width="300" >
<br><br>

# main Idea:
in TLS protocol (even latest v1.3)  SNI is transfered in plain-text.<br>
GFW finds it and when SNI is not in whitelist, replies with TCP-RST.<br>
So that filters cloudflare-ip, based on the SNI, such that some popular sites<br>
like plos.org is open; and all other sites are closed through that ip.<br>
Therefore, we need to hide SNI from GFW.<br>
We fragment TLS "client Hello" packet into chunks in a simple manner.<br>
We show that it'll pass the firewall;<br>
more importantly, we show that GFW can't fix it. Because its nearly impossible<br>
to cache TBs of data in high speed router. Hence, they MUST give up or break the whole network.<br>
<br>
<img src="/asset/slide1.png?raw=true" width="600" >
<br><br>


# about SNI, ESNI & ECH (skip if you want)
leaking domain name (SNI) is the old famous bug of TLS protocol which is not fixed yet as of 2023.<br>
Some attempts started few years ago, trying to encrypt SNI in a project called ESNI which is deprecated today.<br>
cloudflare stopped supporting ESNI in summer 2022.<br>
Another way is the Encrypted Client Hello (ECH) which is in draft version and not well-documented.<br>
I made so much effort to use ECH, but its too complex and still in development.<br>
Also, it's based on DNS-over-HTTPS which is already filtered by GFW.<br>

# about GFW SNI filtering on cloudflare IPs (skip if you want)
cloudflare IPs are high traffic and 30% of web is behind them;<br>
So GFW can't simply block them by traffic volume.<br>
Plus, all the traffic is encrypted except for client hello which leaks the server name (SNI).<br>
<br><br>
So GFW extracts SNI from client hello and when SNI is in white list, it passes.<br><br>
![Alt text](/asset/plos-not-filtered.png?raw=true "plos.org is in whitelist")
<br><br>
But if SNI is in blacklist, GFW sends TCP-RST to terminate the tcp socket.<br><br>
![Alt text](/asset/youtube-filtered.png?raw=true "youtube is in backlist")
<br><br>

# about packet fragment (skip if you want)
We hide SNI by fragmenting client hello packet into several chunks.<br>
But GFW already knew this and tries to assemble those chunks to find SNI!<br>
So, we add a time delay between fragment. LOL.<br>
Since cloudflare IPs have too much traffic, GFW is not able to wait too long. LOL<br>
GFW high-speed cache is limited so it doesn't have the ability to cache TBs of data looking for a tiny tcp fragment. LOL<br>
And that's why, it forgets those fragments after a second. LOL<br>
It's impossible to looking at huge traffic for a packet not knowing when or where it has arrived. LOL<br>
So it's forced to give up! ğŸ˜<br>

# how to run
1. Assume that you have v2ray config {websocket+tls+Cloudflare}.<br>
2. Setup pyprox listen_port and cloudflare_dirty_ip.<br>
<img src="/asset/pyprox_tcp_setup.png?raw=true" ><br>
3. Setup your v2ray client to forward to 127.0.0.1:listen_port<br>
<img src="/asset/v2rayng_setup.png?raw=true".><br>
4. Nn your local machine, run<br>
<code>python pyprox_tcp.py</code.><br>
5. Monitor traffic by Wireshark or Microsoft Network Monitor.<br>
6. Adjust fragment_size & fragment_sleep.<br>
Typical Client Hello packet is ~300 byte.<br>
We split 300 into {77+77+77+69} and send each by delay of 0.3 second.<br>
<code>fragment_size=77 byte  ,  fragment_sleep=0.3 sec -> moderate packet sizes with moderated delays -> works good</code><br>
another setup might be:<br>
<code>fragment_size=77 byte  ,  fragment_sleep=0.2 sec -> moderate packet sizes with moderated delays -> works nice</code><br>
<code>fragment_size=17 byte  ,  fragment_sleep=0.03 sec -> very small chunk with less delay -> works good</code><br>
<code>very big chunk -> assembled by GFW -> TCP-RST recieved</code><br>
<code>too small delay  -> assembled by GFW -> TCP-RST recieved</code><br>
7. Just surf the web using your filtered SNI and a dirty cloudflare IP!<br>

# we are working on it to adjust parameters better
it might be slow at initiating tls handshake;<br>
but we make it better by setting up persistent TLS.<br>
Stay tuned!<br>

# TO DO NEXT
1. Implement this method into v2ray clients or xray-core -> Client Hello Fragmentation option.<br>
2. Setting up persistent TLS (thus one handshake is enough for everything).<br>
3. Sending TCP packets in reverse time order.<br>
4. All your ideas are welcome!<br>



